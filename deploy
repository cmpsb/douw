#!/usr/bin/env python3

import argparse
import time
import datetime
import os
import sys
import subprocess
import fnmatch
import shutil

import sqlite3

currentTime = str(time.time())


def main():
    parser = argparse.ArgumentParser(
        description='Manage website deployments'
    )

    parser.add_argument('--basedir', metavar='PATH', default='/srv/www/sites',
                        help='the directories the sites are stored in')

    subparsers = parser.add_subparsers(title='action', dest='action', metavar='ACTION')
    subparsers.required = True

    listParser = subparsers.add_parser('list', help='list all known sites')
    listParser.set_defaults(action=list)

    listParser.add_argument('--site', metavar='*', default='*',
                            help='a glob-style pattern to filter site names')
    listParser.add_argument('--remote', metavar='*', default='*',
                            help='a glob-style pattern to filter remote URLs')

    depsParser = subparsers.add_parser('deployments', help='list all deployments')
    depsParser.set_defaults(action=deps)

    depsParser.add_argument('--site', metavar='*', default='*',
                            help='a glob-style pattern to filter site names')

    addParser = subparsers.add_parser('add', help='add a site')
    addParser.set_defaults(action=add)

    deployParser = subparsers.add_parser('deploy', help='deploy one or more sites')
    deployParser.set_defaults(action=deploy)

    deployParser.add_argument('site', metavar='SITE',
                             help='a site to deploy')

    revertParser = subparsers.add_parser('revert', help='revert to a previous revision')
    revertParser.set_defaults(action=revert)

    revertParser.add_argument('site', metavar='SITE', nargs='?', default=None)
    revertParser.add_argument('rev', metavar='REV', nargs='?', default=None)

    args = parser.parse_args()

    if not os.path.isdir(args.basedir):
        raise FileNotFoundError(args.basedir)

    args.action(args)


def init_db(db):
    db.executescript("""
CREATE TABLE IF NOT EXISTS site (
    name TEXT PRIMARY KEY NOT NULL,
    remote TEXT NOT NULL,
    env TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS deployment (
    id INTEGER PRIMARY KEY NOT NULL,
    path TEXT NOT NULL,
    revision TEXT NOT NULL,
    date INTEGER NOT NULL,
    active INTEGER NOT NULL,
    present INTEGER NOT NULL DEFAULT 1
);
""")


def get_site_db(basedir, name):
    return os.path.join(basedir, name, 'site.db')

def open_site_db(basedir, name):
    db_path = get_site_db(basedir, name)
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    return conn


def get_info_by_name(db, name):
    db.execute('SELECT site.remote FROM site WHERE site.name = ?;', (name,))

    siteInfo = db.fetchone()
    if siteInfo is None:
        raise Exception("Site {} is unknown".format(name))

    return siteInfo['id'], siteInfo['remote']


def accessible_sites(basedir):
    for ent in os.scandir(basedir):
        ent_db = get_site_db(basedir, ent.name)
        if os.access(ent_db, os.R_OK | os.W_OK):
            conn = sqlite3.connect(ent_db)
            conn.row_factory = sqlite3.Row
            db = conn.cursor()

            db.execute('SELECT name, remote FROM site;')

            yield db.fetchone()

            conn.close()


def list(args):
    sites = [*accessible_sites(args.basedir)]

    # For each column, find the longest string.
    lengths = {'name': 4, 'remote': 6}
    for site in sites:
        if not (fnmatch.fnmatch(site['name'], args.site)
                 and fnmatch.fnmatch(site['remote'], args.remote)):
            continue

        for column in site.keys():
            lengths[column] = max(lengths[column], len(site[column]))

    print_site_listing(lengths, {'name': 'site', 'remote': 'remote'})

    for site in sites:
        if not (fnmatch.fnmatch(site['name'], args.site)
                 and fnmatch.fnmatch(site['remote'], args.remote)):
            continue

        print_site_listing(lengths, site)


def print_site_listing(lengths, site):
    print("{:<{name_width}} | {:<{remote_width}}".format(
        site['name'],
        site['remote'],
        name_width=lengths['name'],
        remote_width=lengths['remote']
    ))


def deps(args):
    conn = open_site_db(args.basedir, args.site)
    db = conn.cursor()

    db.execute('SELECT deployments.path, deployments.date, deployments.active, sites.name ' +
                 'FROM deployments ' +
                 'JOIN sites ON deployments.site = sites.id ' +
                 'ORDER BY date ASC;')

    dbDeployments = db.fetchall()
    deployments = []

    # Translate each timestamp into a date and calculate the required column widths.
    lengths = {'path': 4, 'date': 4, 'active': 1, 'name': 4}
    for dbDep in dbDeployments:
        deployment = {}

        for column in dbDep.keys():
            deployment[column] = dbDep[column]

        deployment['date'] = datetime.datetime.utcfromtimestamp(int(dbDep['date'])).isoformat()

        for column in dbDep.keys():
            if column == 'active':
                continue

            lengths[column] = max(lengths[column], len(deployment[column]))

        deployments.append(deployment)

    print_dep_listing(lengths, {
        'active': True, 'name': 'site', 'path': 'path', 'date': 'date'}
    )

    for deployment in deployments:
        if not fnmatch.fnmatch(deployment['name'], args.site):
            continue

        print_dep_listing(lengths, deployment)

    conn.close()


def print_dep_listing(lengths, dep):
    print("{} | {:<{name_width}} | {:<{path_width}} | {:<{date_width}}".format(
          ('*' if dep['active'] else ' '),
          dep['name'],
          dep['path'],
          dep['date'],
          name_width=lengths['name'],
          path_width=lengths['path'],
          date_width=lengths['date']))


def add(args):
    site_name = prompt_nonempty('Site name')
    remote = prompt_default('Remote', 'git.wukl.net:wukl/' + site_name)
    config = prompt_default('DTAP Environment', 'P')

    site_dir = os.path.join(args.basedir, site_name)
    os.makedirs(site_dir, mode=0o0775, exist_ok=True)

    conn = open_site_db(args.basedir, site_name)
    db = conn.cursor()

    init_db(db)
    db.execute('INSERT INTO site (name, remote, env) VALUES (?, ?, ?)', (site_name, remote, config))

    conn.commit()
    conn.close()


def prompt_default(prompt, default):
    value = input(prompt + ' [' + default + ']: ')
    if not value:
        return default
    else:
        return value


def prompt_nonempty(prompt):
    value = input(prompt + ': ')
    if value:
        return value

    return prompt_nonempty(prompt)


def deploy(args):
    site = args.site

    conn = open_site_db(args.basedir, site)
    db = conn.cursor()

    siteId, repo = get_info_by_name(db, site)
    siteDir = args.basedir + '/' + site

    deployDir = siteDir + '/deployments/.' + currentTime

    print("\033[32;1mDeploying " + site + ".\033[0m")

    os.makedirs(deployDir, mode=0o755, exist_ok=True)

    subprocess.run(['git', 'clone', repo, deployDir + '/'], check=True)
    result = subprocess.run(['git', 'rev-parse', 'HEAD'],
                            stdout=subprocess.PIPE, check=True, cwd=deployDir)
    revId = result.stdout.decode('utf8').partition("\n")[0]

    print("\033[32;1mFound revision " + revId + ".\033[0m")

    db.execute('INSERT INTO deployment (path, revision, date, active) VALUES (?, ?, ?, 0);',
               (siteId, deployDir, revId, int(time.time())))

    conn.commit()
    conn.close()

    activate(args, siteId, site, revId)

    clean(args)


def activate(args, id, site, revision):
    conn = open_site_db(args.basedir, site)
    db = conn.cursor()

    db.execute('UPDATE deployment SET active = 0;', (id,))

    siteDir = args.basedir + '/' + site
    linkName = siteDir + '/current'

    sharedPath = siteDir + '/shared'
    sharedLinkName = linkName + '/htdocs/shared'

    db.execute('SELECT path '
               + 'FROM deployments '
               + 'WHERE site = ? '
               +   'AND revision = ?', (id, revision))

    pathInfo = db.fetchone()
    if pathInfo is None:
        raise Exception('No revision {} for site {}'.format(revision, site))

    path = pathInfo['path']

    if os.path.islink(linkName):
        subprocess.run(['rm', linkName])

    subprocess.run(['ln', '-s', path, linkName], check=True)

    if os.path.exists(sharedPath):
        if os.path.islink(sharedLinkName):
            subprocess.run(['rm', sharedLinkName])

        subprocess.run(['ln', '-s', sharedPath, sharedLinkName], check=True)

    db.execute('UPDATE deployments '
               + 'SET active = 1 '
               + 'WHERE revision = ?', (revision,))

    conn.commit()
    conn.close()


def revert(args):
    site = args.site

    conn = open_site_db(args.basedir, site)
    db = conn.cursor()

    if site is None:
        db.execute('SELECT sites.id, sites.name '
                   + 'FROM deployments '
                   + 'JOIN sites ON sites.id = deployments.site '
                   + 'ORDER BY deployments.id DESC '
                   + 'LIMIT 1;')

        siteInfo = db.fetchone()
        site = siteInfo['name']
        siteId = siteInfo['id']
    else:
        siteId, siteRepo = get_info_by_name(db, site)

    rev = args.rev
    if rev is None:
        db.execute('SELECT revision '
                   + 'FROM deployments '
                   + 'WHERE site = ? '
                   +   'AND active <> 1 '
                   +   'AND present = 1 '
                   + 'ORDER BY date DESC '
                   + 'LIMIT 1', (siteId,))

        revInfo = db.fetchone()
        if revInfo is None:
          raise Exception('No available previous deployment to revert to')

        rev = revInfo['rev']

    activate(args, siteId, site, rev)

    conn.commit()
    conn.close()


def clean(args):
    site_name = args.site

    conn = open_site_db(args.basedir, site_name)
    db = conn.cursor()

    db.connection.commit()
    db.execute('SELECT deployments.id, deployments.path '
               + 'FROM deployments '
               + 'JOIN sites ON deployments.site = sites.id '
               + 'WHERE sites.name = ? '
               +   'AND deployments.active <> 1 '
               +   'AND deployments.present = 1 '
               + 'ORDER BY deployments.date DESC '
               + 'LIMIT 1000000 OFFSET 4;', (site_name,))

    results = db.fetchall()

    for result in results:
        print('\033[33;1mDeleting', result['path'], '\033[0m')

        try:
          shutil.rmtree(result['path'])
        except:
          pass

        db.execute('UPDATE deployments '
                   + 'SET present = 0 '
                   + 'WHERE id = ?', (result['id'],))

    conn.commit()
    conn.close()


try:
    main()
except Exception:
    print("\033[31;1m")
    raise
